<html>
  <head>
    <style>
      item { height: 100px }
    </style>
    
  </head>
  <body>
    <div style="float: left">
      number of items <input id=items value=1000></input><br>
      item height (px) <input id=itemHeight value=100></input><br>
      pre-fill (number of screens) <input id=preFill value=0.0></input><br>
      pre-fill (number of screens) <input id=postFill value=0.0></input><br>
      log to console <input id=logi type=checkbox value=0></input><br>
      sleep (ms) <input id=sleepi value=0></input><br>
      <input type=submit onclick="reconfigure()">
    </div>
    <div id=scroller style="overflow: scroll; height: 100%; float: right; width: 50%">
      <div id=topd style="bgcolor: black"></div>
      <div id=contentd></div>
      <div id=bottomd></div>
    </div>
    <script>
      var config;
      function reconfigure() {
        config = new Object();
        config.items = parseInt(items.value);
        config.itemHeight = parseInt(itemHeight.value);
        // How many screens of content to pre-/post-fill.
        config.preFill = parseFloat(preFill.value);
        config.postFill = parseFloat(postFill.value);
        config.sleepMs = parseInt(sleepi.value);
        config.log = logi.checked;
        moveScroll(0);
        scroller.scrollTop = 0;
      }
      function sleep(ms) {
        var limit = new Date().getTime() + ms;

        while (limit >= new Date().getTime()) {
        }
      }

      function setHeight(e, h) {
        e.style.height = h;
      }
      
      function createItem(n) {
        var item = document.createElement("div");
        item.className = "item"
        item.innerText = "item " + n;
        setHeight(item, config.itemHeight);
        return item;
      }

      let topItem = 0;
      let bottomItem = 0;

      function log(...m) {
        if (config.log) {
          console.log(...m);
        }
      }

      // Redraw the visible items after a scroll.
      function moveScroll(scrollPos) {
        totalHeight = config.itemHeight * config.items;
        log("scrollPos", scrollPos);
        // How many items can we fit in the window?
        var itemsPer = Math.ceil(scroller.clientHeight / config.itemHeight);
        log("itemsPer", itemsPer);
        var firstVisibleItem = Math.min(config.items - 1 - itemsPer,
                                        Math.floor(scrollPos / config.itemHeight));

        // Can render more items above the first visible one.
        var firstItem = Math.max(0, firstVisibleItem - config.preFill * itemsPer);
        log("firstItem", firstItem);

        var lastVisibleItem = firstVisibleItem + itemsPer;
        // Can render more items below the last visible one.
        var lastItem = Math.min(config.items - 1, lastVisibleItem + config.postFill * itemsPer);
        log("lastItem", lastItem);

        var renderedItems = lastItem - firstItem + 1;
        // Replace the old items.
        contentd.innerHTML = "";
        for (var i = firstItem; i <= lastItem; i++) {
          contentd.appendChild(createItem(i));
        }

        // Now set heights on the spacers.
        var topHeight = config.itemHeight * firstItem;
        setHeight(topd, topHeight);
        log("topHeight", topHeight);
        var contentHeight = config.itemHeight * renderedItems;
        setHeight(contentd, contentHeight);
        var bottomHeight = totalHeight - topHeight - contentHeight;
        setHeight(bottomd, bottomHeight);
        log("bottomHeight", bottomHeight);
        sleep(config.sleepMs);
      }

      // Only generate 1 redraw per frame.
      let lastPosition = 0;
      let ticking = false;
      scroller.addEventListener('scroll', function(e) {
        // BUG: If scroll down, we generate more and more scroll down
        // events. Why? It seems like redoing the heights causes
        // scroll events. Is the scroll-bar following the top of
        // bottomd or something?
        log("lastPosition", lastPosition);
        log("scroller.scrollTop", scroller.scrollTop);
        if (lastPosition == scroller.scrollTop) {
          return;
        }

        lastPosition = scroller.scrollTop;

        if (!ticking) {
          window.requestAnimationFrame(function() {
            /*
            log(topd.getBoundingClientRect());
            log(contentd.getBoundingClientRect());
            log(bottomd.getBoundingClientRect());
            log(topd.getBoundingClientRect().height +
                contentd.getBoundingClientRect().height +
                bottomd.getBoundingClientRect().height);
            log(scroller.getBoundingClientRect());
*/
            moveScroll(lastPosition);
            ticking = false;
          });

          ticking = true;
        }
      });
      reconfigure();
    </script>
    
  </body>  
</html>
