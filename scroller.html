<html>
  <head>
    <style>
      item { height: 100px }
    </style>
    
  </head>
  <body>
    <div style="float: left">
      number of items <input id=items value=1000></input><br>
      item height (px) <input id=itemHeight value=100></input><br>
      pre-fill (number of screens) <input id=preFill value=0.0></input><br>
      pre-fill (number of screens) <input id=postFill value=0.0></input><br>
      log to console <input id=logi type=checkbox value=0></input><br>
      sleep (ms) <input id=sleepi value=0></input><br>
      <input type=submit onclick="reconfigure()">
    </div>
    <div id=scroller style="overflow: scroll; height: 100%; float: right; width: 50%">
      <div id=scrollerInner>
      </div>
    </div>
    <script>
      var config;
      function reconfigure() {
        config = new Object();
        config.items = parseInt(items.value);
        config.itemHeight = parseInt(itemHeight.value);
        // How many screens of content to pre-/post-fill.
        config.preFill = parseFloat(preFill.value);
        config.postFill = parseFloat(postFill.value);
        config.sleepMs = parseInt(sleepi.value);
        config.log = logi.checked;
        moveScroll(0);
        scroller.scrollTop = 0;
      }
      function sleep(ms) {
        var limit = new Date().getTime() + ms;

        while (limit >= new Date().getTime()) {
        }
      }

      function setHeight(e, h) {
        e.style.height = h;
      }
      
      function createItem(n) {
        var item = document.createElement("div");
        item.className = "item"
        item.innerText = "item " + n;
        setHeight(item, config.itemHeight);
        return item;
      }

      let topItem = 0;
      let bottomItem = 0;

      function log(...m) {
        if (config.log) {
          console.log(...m);
        }
      }

      function getFirstLastItem(config, scrollPos) {
        // How many items can we fit in the window?
        var itemsPer = Math.ceil(scroller.clientHeight / config.itemHeight);
        log("itemsPer", itemsPer);
        var firstVisibleItem = Math.min(config.items - 1 - itemsPer,
                                        Math.floor(scrollPos / config.itemHeight));

        // Can render more items above the first visible one.
        var firstItem = Math.max(0, firstVisibleItem - config.preFill * itemsPer);
        log("firstItem", firstItem);

        var lastVisibleItem = firstVisibleItem + itemsPer;
        // Can render more items below the last visible one.
        var lastItem = Math.min(config.items - 1, lastVisibleItem + config.postFill * itemsPer);
        log("lastItem", lastItem);
        return [firstItem, lastItem];
      }

      function appendSpaceAndItems(config, skipItems, firstItem, numItems) {
        var spacerDiv = document.createElement("div");
        var spacerHeight = skipItems * config.itemHeight;
        setHeight(spacerDiv, spacerHeight);
        log("spacerHeight", spacerHeight);
        scrollerInner.appendChild(spacerDiv);

        var itemsDiv = document.createElement("div");
        lastItem = firstItem + numItems - 1;
        for (var i = firstItem; i <= lastItem; i++) {
          itemsDiv.appendChild(createItem(i));
        }
        var itemsHeight = config.itemHeight * numItems;
        setHeight(itemsDiv, itemsHeight);
        log("itemsDiv height", itemsHeight);
        scrollerInner.appendChild(itemsDiv);

        return spacerHeight + itemsHeight;
      }

      // Redraw the visible items after a scroll.
      function moveScroll(scrollPos) {
        let totalHeight = config.itemHeight * config.items;
        log("scrollPos", scrollPos);

        // Can render more items above the first visible one.
        var [firstItem, lastItem] = getFirstLastItem(config, scrollPos);
        var numItems = lastItem - firstItem + 1;

        // Remove all contents.
        scrollerInner.innerHTML = "";
        var usedHeight = appendSpaceAndItems(config, firstItem, firstItem, numItems);
        log("usedHeight", usedHeight);

        var remainingItems = config.items - lastItem - 1;
        usedHeight += appendSpaceAndItems(config, remainingItems, 0, 0);
        log("usedHeight", usedHeight);
        if (usedHeight != totalHeight) {
          console.error("usedHeight != totalHeight", usedHeight, totalHeight);
        }
        sleep(config.sleepMs);
      }

      // Only generate 1 redraw per frame.
      let lastPosition = 0;
      let ticking = false;
      scroller.addEventListener('scroll', function(e) {
        // BUG: If scroll down, we generate more and more scroll down
        // events. Why? It seems like redoing the heights causes
        // scroll events. Is the scroll-bar following the top of
        // bottomd or something?
        log("lastPosition", lastPosition);
        log("scroller.scrollTop", scroller.scrollTop);
        if (lastPosition == scroller.scrollTop) {
          return;
        }

        lastPosition = scroller.scrollTop;

        if (!ticking) {
          window.requestAnimationFrame(function() {
            /*
            log(topd.getBoundingClientRect());
            log(contentd.getBoundingClientRect());
            log(bottomd.getBoundingClientRect());
            log(topd.getBoundingClientRect().height +
                contentd.getBoundingClientRect().height +
                bottomd.getBoundingClientRect().height);
            log(scroller.getBoundingClientRect());
*/
            moveScroll(lastPosition);
            ticking = false;
          });

          ticking = true;
        }
      });
      reconfigure();
    </script>
    
  </body>  
</html>
